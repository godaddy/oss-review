import diagnostics from 'diagnostics';
import { spawn as defaultSpawn } from 'node:child_process';
import type { ChildProcess } from 'node:child_process';
import { randomUUID } from 'node:crypto';
import type { Stats, Dirent } from 'node:fs';
import { promises as fs } from 'node:fs';
import { join, resolve } from 'node:path';
import { tmpdir } from 'node:os';

const debug = diagnostics('oss-review:syft');

/**
 * SPDX-like metadata describing the licences associated with a component in a CycloneDX BOM.
 */
export interface CycloneDxLicense {
  /** SPDX identifier (preferred) or a descriptive name. */
  license?: {
    id?: string;
    name?: string;
    url?: string;
  };
  /** SPDX licence expression when multiple licences apply. */
  expression?: string;
}

/**
 * Minimal representation of a CycloneDX component required for licence analysis.
 */
export interface CycloneDxComponent {
  bomRef?: string;
  name?: string;
  version?: string;
  type?: string;
  purl?: string;
  licenses?: CycloneDxLicense[];
  evidence?: {
    licenses?: CycloneDxLicense[];
  };
}

/**
 * CycloneDX Software Bill of Materials payload generated by Syft.
 */
export interface CycloneDxBom {
  bomFormat?: string;
  metadata?: {
    component?: CycloneDxComponent;
  };
  components?: CycloneDxComponent[];
}

/**
 * Configuration accepted by {@link SyftScanner} when constructing an instance.
 */
export interface SyftScannerOptions {
  /** Optional path to the Syft executable (defaults to `syft` on PATH). */
  executable?: string;
  /** Environment variables to forward to spawned Syft processes. */
  env?: NodeJS.ProcessEnv;
  /** Optional logger invoked with human-readable run messages. */
  logger?: (message: string) => void;
  /** Optional custom spawner for testing (defaults to node:child_process spawn). */
  spawn?: typeof defaultSpawn;
}

/**
 * Options passed to {@link SyftScanner.scanDirectory} when generating a BOM.
 */
export interface SyftScanOptions {
  /** When true include development dependencies (passed via additional args). */
  includeDev?: boolean;
  /** Additional raw arguments forwarded to the underlying Syft invocation. */
  additionalArgs?: string[];
}

/**
 * Options supplied to {@link SyftScanner.available} to customise availability checks.
 */
export interface SyftAvailabilityOptions {
  /** Alternate executable path to probe instead of the default `syft`. */
  executable?: string;
  /** Environment variables to use when probing for Syft. */
  env?: NodeJS.ProcessEnv;
  /** Raw arguments forwarded to the probe command (defaults to `--version`). */
  args?: string[];
  /** Optional custom spawn implementation (primarily for tests). */
  spawn?: typeof defaultSpawn;
}

/**
 * Result returned by {@link SyftScanner.scanDirectory} describing the generated BOM.
 */
export interface SyftScanResult {
  /** Parsed CycloneDx BOM generated by Syft. */
  bom: CycloneDxBom;
  /** Short description of the source command (human readable). */
  source: string;
  /** Collection of manifest hints detected prior to scanning. */
  warnings: string[];
  /** Underlying command invocation executed to produce the BOM. */
  command: {
    executable: string;
    args: string[];
  };
}

/**
 * Entry describing an analysed component with its derived licence strings.
 */
export interface BomComponentEntry {
  key: string;
  component: CycloneDxComponent;
  licenses: string[];
}

/**
 * Aggregated view over a CycloneDx SBOM used for downstream analysis.
 */
export interface BomAnalysis {
  /** Total number of components (including root metadata component when present). */
  totalComponents: number;
  /** Ordered list of components evaluated during the analysis. */
  components: CycloneDxComponent[];
  /** Analysed components paired with derived licence strings. */
  entries: BomComponentEntry[];
}

const HINT_FILES: Array<{ file: string; hint: string }> = [
  { file: 'package.json', hint: 'Node.js manifest detected. Syft auto-detects npm/pnpm/yarn projects.' },
  { file: 'package-lock.json', hint: 'Node.js lockfile detected. Ensure dependencies are refreshed before scanning.' },
  { file: 'pnpm-lock.yaml', hint: 'pnpm lockfile detected.' },
  { file: 'yarn.lock', hint: 'Yarn lockfile detected.' },
  { file: 'go.mod', hint: 'Go module detected. Syft catalogs Go modules automatically.' },
  { file: 'Cargo.toml', hint: 'Rust crate manifest detected.' },
  { file: 'Cargo.lock', hint: 'Rust lockfile detected.' },
  { file: 'requirements.txt', hint: 'Python requirements file detected.' },
  { file: 'pyproject.toml', hint: 'Python poetry project detected.' },
  { file: 'Pipfile.lock', hint: 'Python pipenv lockfile detected.' },
  { file: 'composer.lock', hint: 'PHP Composer lockfile detected.' },
  { file: 'Gemfile.lock', hint: 'Ruby Bundler lockfile detected.' },
  { file: 'build.gradle', hint: 'Gradle build file detected.' },
  { file: 'pom.xml', hint: 'Maven project detected.' }
];

export class SyftScanner {
  private readonly executable: string;
  private readonly env?: NodeJS.ProcessEnv;
  private readonly logger?: (message: string) => void;
  private readonly spawnCommand: typeof defaultSpawn;

  /**
   * Create a new Syft scanner wrapper.
   *
   * @param options - Optional configuration for the wrapper instance.
   * @param options.executable - Path to the Syft executable (defaults to `syft`).
   * @param options.env - Environment variables forwarded to spawned processes.
   * @param options.logger - Optional logger callback for human-readable messages.
   */
  constructor(options: SyftScannerOptions = {}) {
    this.executable = options.executable?.trim() || 'syft';
    this.env = options.env;
    this.logger = options.logger;
    this.spawnCommand = options.spawn ?? defaultSpawn;
  }

  /**
   * Retrieve the Syft executable path configured for this scanner instance.
   *
   * @returns Executable path used when invoking Syft.
   */
  getExecutable(): string {
    return this.executable;
  }

  /**
   * Determine whether the Syft CLI is available on the system PATH.
   *
   * @param options - Optional overrides controlling the availability probe.
   * @param options.executable - Alternate executable path to probe instead of `syft`.
   * @param options.env - Environment variables to supply when invoking Syft.
   * @param options.args - Raw command-line arguments used for the probe (defaults to `--version`).
   * @returns Promise resolving with `true` when Syft executes successfully.
   */
  static async available(options: SyftAvailabilityOptions = {}): Promise<boolean> {
    const executable = options.executable?.trim() || 'syft';
    const args = options.args ?? ['--version'];

    debug('checking syft availability via %s %o', executable, args);

    return await new Promise((resolve) => {
      const child = (options.spawn ?? defaultSpawn)(executable, args, {
        env: options.env ?? process.env,
        stdio: ['ignore', 'ignore', 'ignore']
      });

      child.on('error', (error) => {
        debug('syft availability check failed: %o', error);
        resolve(false);
      });

      child.on('close', (code) => {
        resolve(code === 0);
      });
    });
  }

  /**
   * Generate a CycloneDX SBOM for the provided directory using the Syft CLI.
   *
   * @param target - Absolute or relative path to the directory to scan.
   * @param options - Optional scan behaviour overrides.
   * @param options.includeDev - When `true`, include development dependencies.
   * @param options.additionalArgs - Extra CLI arguments appended to the Syft invocation.
   * @returns Promise resolving with the parsed CycloneDX BOM and invocation metadata.
   */
  async scanDirectory(target: string, options: SyftScanOptions = {}): Promise<SyftScanResult> {
    const root = resolve(target);
    const hints = await this.collectHints(root);

    const output = join(tmpdir(), `oss-review-syft-${randomUUID()}.json`);
    const args = ['scan', `dir:${root}`, '-o', `cyclonedx-json=${output}`, '--quiet'];
    if (options.includeDev) args.push('--select-catalogers', 'all-packages');
    if (options.additionalArgs?.length) args.push(...options.additionalArgs);

    await this.exec(args, root);

    try {
      const bom = await this.readSbom(output);
      return {
        bom,
        source: `${this.executable} cyclonedx-json`,
        warnings: hints,
        command: {
          executable: this.executable,
          args
        }
      };
    } finally {
      await fs.rm(output, { force: true });
    }
  }

  /**
   * Inspect a directory for known manifest files and emit operator hints.
   *
   * @param root - Directory path to inspect.
   * @returns Promise that resolves with an array of human-readable hint strings.
   */
  async collectHints(root: string): Promise<string[]> {
    let entries: Dirent[] = [];
    try {
      entries = await fs.readdir(root, { withFileTypes: true });
    } catch (error) {
      debug('failed to read directory %s: %o', root, error);
      return [];
    }

    return entries
      .filter((entry) => entry.isFile())
      .map((entry) => HINT_FILES.find((candidate) => candidate.file === entry.name))
      .filter((item): item is { file: string; hint: string } => Boolean(item))
      .map((item) => item.hint);
  }

  /**
   * Read and parse a CycloneDX SBOM from disk.
   *
   * @param path - Path to the CycloneDX JSON file.
   * @returns Promise resolving with the parsed CycloneDx BOM object.
   */
  async readSbom(path: string): Promise<CycloneDxBom> {
    const resolved = resolve(path);
    const stats = await this.statSafe(resolved);
    if (!stats?.isFile()) throw new Error(`SBOM file not found: ${resolved}`);

    const text = await fs.readFile(resolved, 'utf8');
    try {
      return JSON.parse(text) as CycloneDxBom;
    } catch (error) {
      throw new Error(`Failed to parse SBOM at ${resolved}: ${(error as Error).message}`);
    }
  }

  /**
   * Execute the Syft CLI with the provided arguments.
   *
   * @param args - Command-line arguments to forward to Syft.
   * @param cwd - Working directory used for the command invocation.
   * @returns Promise that resolves once Syft exits successfully.
   */
  protected async exec(args: string[], cwd: string): Promise<void> {
    this.logger?.(`running ${this.executable} ${args.join(' ')}`);
    debug('exec %s %o', this.executable, args);

    const { code, stderr } = await this.spawn(args, cwd);
    if (code !== 0) {
      throw new Error(`Syft failed with exit code ${code}: ${stderr.trim()}`);
    }
  }

  /**
   * Spawn the Syft process and collect stdout/stderr for debugging.
   *
   * @param args - Command-line arguments to pass to Syft.
   * @param cwd - Working directory for the spawned process.
   * @returns Promise resolving with the captured exit code and standard streams.
   */
  protected async spawn(args: string[], cwd: string): Promise<{ code: number | null; stdout: string; stderr: string }> {
    return await new Promise((resolvePromise, reject) => {
      const child: ChildProcess = this.spawnCommand(this.executable, args, {
        cwd,
        env: this.env ?? process.env,
        stdio: ['ignore', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      child.stdout?.on('data', (chunk) => (stdout += chunk));
      child.stderr?.on('data', (chunk) => (stderr += chunk));

      child.on('error', reject);
      child.on('close', (code) => resolvePromise({ code, stdout, stderr }));
    });
  }

  /**
   * Safe fs.stat wrapper returning null when the path does not exist.
   *
    * @param path - Filesystem path to inspect.
    * @returns Promise resolving with the file stats or `null` when absent.
   */
  protected async statSafe(path: string): Promise<Stats | null> {
    try {
      return await fs.stat(path);
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') return null;
      throw error;
    }
  }
}

/**
 * Analyse a parsed CycloneDX BOM and extract high-level metadata.
 *
 * @param bom - CycloneDX bill of materials to inspect.
 * @returns Summary containing component list and licence mapping.
 */
export function analyzeBom(bom: CycloneDxBom): BomAnalysis {
  const components: CycloneDxComponent[] = [];

  if (bom.metadata?.component) components.push(bom.metadata.component);
  if (Array.isArray(bom.components)) components.push(...bom.components);

  const entries: BomComponentEntry[] = components.map((component, index) => {
    const bucket = new Set<string>();
    const collect = (entry?: CycloneDxLicense) => {
      if (!entry) return;
      if (entry.license?.id) bucket.add(entry.license.id);
      if (entry.license?.name) bucket.add(entry.license.name);
      if (entry.expression) bucket.add(entry.expression);
    };

    component.licenses?.forEach((license) => collect(license));
    component.evidence?.licenses?.forEach((license) => collect(license));

    const key = component.name ?? component.bomRef ?? `component-${index}`;
    return {
      key,
      component,
      licenses: Array.from(bucket)
    };
  });

  return {
    totalComponents: components.length,
    components,
    entries
  };
}

/**
 * Load and analyse a CycloneDX BOM from disk.
 *
 * @param path - Filesystem path to a CycloneDX JSON document.
 * @returns Summary containing component list and licence mapping.
 */
export async function analyzeSbomFile(path: string): Promise<BomAnalysis> {
  const scanner = new SyftScanner();
  const bom = await scanner.readSbom(path);
  return analyzeBom(bom);
}

export default SyftScanner;


